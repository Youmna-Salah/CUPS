
import java_cup.runtime.*;


/* Terminals (tokens returned by the scanner). */
terminal CONST;
terminal INCREMENT;
terminal VAR;
terminal IF;
terminal COLON_EQUAL;
terminal ELSE;
terminal COMMENT;
terminal REL_OP;
terminal RETURN; 
terminal DOT; 
terminal COMMA;
terminal TYPE;
terminal INT_LIT;
terminal SLASH;
terminal SWITCH;
terminal CASE;
terminal DEFAULT;
terminal  FOR;
terminal STRUCT;
terminal PACKAGE;
terminal IMPORT;
terminal  EQUAL;
terminal  COLON;
terminal  IDENTIFIER;
terminal  OR_OPR;
terminal  AND_OP;
terminal   DOTS;
terminal   PLUS;
terminal   MINUS;
terminal   SINGLE_OR;
terminal   ASTRISK;
terminal   PERCENT;
terminal   SHIFTLEFT;
terminal   SHIFTRIGHT;
terminal   SINGLE_AND;
terminal    STRING_TEXT;
terminal   OPEN_SQUARE;
terminal   OPEN_CURLY;
terminal   OPEN_PARAN;
terminal   CLOSE_SQUARE;
terminal   CLOSE_CURLY;
terminal   CLOSE_PARAN;
terminal   FUNC;
terminal   EXLIM;
terminal   INFER;
terminal   DECREMENT;
terminal   BREAK;
terminal   SEMI_COLON;
/* Non terminals */
non terminal      sub_element_list;
non terminal      keyed_element;
non terminal      sub_keyed_element;
non terminal      key;
non terminal      element;
non terminal      field_name;
non terminal      expression;
non terminal      qualified_ident;
non terminal      package_name;
non terminal      selector;
non terminal      index;
non terminal      slice;
non terminal      sub_slice;
non terminal      arguments;
non terminal      sub_arguments;
non terminal      sub_sub_arguments;
non terminal      sub_type;
non terminal      sub_sub_type;
non terminal      function_lit;
non terminal      method_expr;
non terminal      receiver_type;
non terminal      method_name;
non terminal      statement;
non terminal      sub_semi_colon;
non terminal      simple_stmt;
non terminal      expression_stmt;
non terminal      inc_dec_stmt;
non terminal      sub_inc_dec_stmt;
non terminal      assignment;
non terminal      assign_op;
non terminal      sub_assign_op;
non terminal      if_stmt;
nonterminal zero_one_init_stmt;
nonterminal zero_one_condition;
nonterminal zero_one_post_stmt;
non terminal      sub_else_stmt;
non terminal      sub_sub_else_stmt;
non terminal      switch_stmt;
non terminal      declaration;
non terminal      return_stmt;
non terminal      break_stmt;
non terminal      block;
non terminal      for_stmt;
non terminal      short_var_decl;
non terminal      expr_switch_stmt;
non terminal      sub_expr_switch_stmt;
non terminal      sub_expr_switch_expr_stmt;
non terminal      zero_expr_switch_stmt;
non terminal      expr_case_clause;
non terminal      expr_switch_case;
non terminal      statement_list;
non terminal      sub_for_stmt;
non terminal      condition;
non terminal      for_clause;
non terminal      sub_init_stmt;
non terminal      sub_condition;
non terminal      sub_post_stmt;
non terminal      init_stmt;
non terminal      post_stmt;
non terminal      sub_return_stmt;
non terminal      package_clause;
non terminal      sub_import_decl;
non terminal      sub_top_level_decl;
non terminal      import_decl;
non terminal      top_level_decl;
non terminal      source_file;
non terminal      import_spec;
non terminal      sub_import_spec;
non terminal      sub_sub_import_decl;
non terminal      sub_import_decll;
non terminal zero_one_var_spec;
non terminal      import_path;
nonterminal       element_list;
nonterminal   	  group_var_spec;
nonterminal   	 tag;
nonterminal   zero_more_identifier_list;
nonterminal   zero_more_expression_list;
nonterminal   expression_list;
nonterminal   unary_expr;
nonterminal   group_type_decl;
nonterminal   type_spec;
nonterminal   zero_more_group_type_decl;
nonterminal   primary_expr;
nonterminal   var_spec;
nonterminal    binary_op;
nonterminal    add_op; 
nonterminal    mul_op;
nonterminal    type; 
nonterminal    type_name; 
nonterminal    type_lit; 
nonterminal    array_type;
nonterminal    array_length;
nonterminal   signature;
nonterminal   basic_lit;
nonterminal    slice_type;
nonterminal    struct_type;
nonterminal   composite_lit;
nonterminal   function;
nonterminal   receiver;
nonterminal   operand;
nonterminal   operand_name;
nonterminal    zero_more_struct_type;
nonterminal    field_decl; 
nonterminal   parameter_list;
nonterminal   statment_list;
nonterminal   const_decl;
nonterminal   type_decl;
nonterminal   parameter_decl;
nonterminal   group_const_decl;
nonterminal   one_more_const_spec;
nonterminal   const_spec;
nonterminal   parameters;
nonterminal    group_field_decl; nonterminal    anonymous_field; nonterminal    identifier_list;
nonterminal   literal_value;
nonterminal   zero_more_var_spec;
nonterminal   literal_type;
nonterminal   literal;
nonterminal   group_function_decl;
nonterminal   function_body;
nonterminal   zero_more_statment;
nonterminal   zero_more_parameter_list;
nonterminal   method_decl;
nonterminal   var_decl;
nonterminal   function_decl;
nonterminal   group_var_decl;
nonterminal   function_name;
nonterminal   result;
nonterminal   unary_op;
nonterminal   function_type;
nonterminal   element_type;

/* Precedences */
precedence left IDENTIFIER, SEMI_COLON, CLOSE_SQUARE, CLOSE_CURLY, CLOSE_PARAN;
precedence left PLUS, MINUS, SINGLE_OR;
precedence left OPEN_SQUARE, OPEN_CURLY, OPEN_PARAN ;
precedence left COMMA, OR_OPR, DOT, PLUS, MINUS, EXLIM, ASTRISK, SINGLE_AND, INFER;
precedence left TYPE, FUNC, STRUCT, STRING_TEXT, INT_LIT, ASTRISK, SLASH, PERCENT, SHIFTRIGHT, SHIFTLEFT,SINGLE_AND;
precedence left	 REL_OP, AND_OP;
precedence left IMPORT, PACKAGE;
start with source_file;

binary_op ::= OR_OPR|AND_OP|REL_OP| add_op|mul_op;
add_op ::= PLUS|MINUS|SINGLE_OR;
mul_op ::= ASTRISK|SLASH|PERCENT|SHIFTRIGHT|SHIFTLEFT|SINGLE_AND;
unary_op ::= PLUS|MINUS|EXLIM|ASTRISK|SINGLE_AND|INFER;
type ::= type_name| type_lit;
type_name ::= IDENTIFIER:i {:System.out.println(i);:};
type_lit ::= array_type| struct_type|function_type|slice_type;
array_type ::= OPEN_SQUARE array_length CLOSE_SQUARE element_type;
array_length ::= expression;
element_type ::= type; 

slice_type ::= OPEN_SQUARE CLOSE_SQUARE element_type;

struct_type ::= STRUCT OPEN_CURLY zero_more_struct_type CLOSE_CURLY;
zero_more_struct_type ::= field_decl SEMI_COLON zero_more_struct_type | ;

field_decl ::= group_field_decl tag| group_field_decl; 
group_field_decl ::= identifier_list type| anonymous_field| ;

anonymous_field ::= ASTRISK type_name| type_name;

tag ::=  STRING_TEXT;
function_type ::= FUNC signature;

signature ::= parameters result| parameters;

result ::= parameters| OPEN_PARAN type CLOSE_PARAN;

parameters ::= OPEN_PARAN parameter_list CLOSE_PARAN| OPEN_PARAN CLOSE_PARAN;


parameter_list ::= parameter_decl zero_more_parameter_list;
zero_more_parameter_list::= COMMA parameter_decl zero_more_parameter_list| ;

parameter_decl ::= identifier_list DOTS type| identifier_list type;

method_name ::= IDENTIFIER;

block ::= OPEN_CURLY statment_list CLOSE_CURLY;

statment_list ::= zero_more_statment;
zero_more_statment ::= statement zero_more_statment|;

declaration ::= const_decl SEMI_COLON| type_decl SEMI_COLON| var_decl SEMI_COLON|type_decl;

top_level_decl ::= declaration |function_decl SEMI_COLON| function_decl| method_decl SEMI_COLON| method_decl;

const_decl ::= CONST group_const_decl;
group_const_decl ::= const_spec|OPEN_PARAN one_more_const_spec CLOSE_PARAN;
one_more_const_spec ::= const_spec SEMI_COLON one_more_const_spec|;

const_spec ::= IDENTIFIER| IDENTIFIER type EQUAL expression|IDENTIFIER EQUAL expression;

identifier_list ::= IDENTIFIER zero_more_identifier_list;
zero_more_identifier_list ::= SEMI_COLON IDENTIFIER zero_more_identifier_list|;

expression_list ::= expression zero_more_expression_list;
zero_more_expression_list ::= COMMA expression zero_more_expression_list|;

expression ::= unary_expr| expression binary_op expression;
unary_expr ::= primary_expr |unary_op unary_expr;

type_decl ::= TYPE group_type_decl;

group_type_decl ::= type_spec| OPEN_PARAN zero_more_group_type_decl CLOSE_PARAN;
zero_more_group_type_decl ::=  type_spec SEMI_COLON zero_more_group_type_decl|;

type_spec ::= IDENTIFIER type;
var_decl ::= VAR group_var_decl;
group_var_decl ::= var_spec| OPEN_PARAN zero_more_var_spec CLOSE_PARAN;
zero_more_var_spec ::= var_spec SEMI_COLON zero_more_var_spec| ;

var_spec ::= IDENTIFIER group_var_spec;
group_var_spec ::= type zero_one_var_spec|EQUAL expression;
zero_one_var_spec ::= EQUAL expression|;
short_var_decl ::= identifier_list COLON_EQUAL expression;

function_decl ::= FUNC function_name group_function_decl;
group_function_decl ::= function|signature;	

function_name ::= IDENTIFIER;
function ::= signature function_body;
function_body::= block;

method_decl::= FUNC receiver method_name group_function_decl;


receiver ::= parameters;
operand ::= literal |operand_name | method_expr| OPEN_PARAN expression CLOSE_PARAN;

literal ::= basic_lit | composite_lit| function_lit;

composite_lit ::= literal_type literal_value;
literal_type ::= struct_type|array_type| OPEN_SQUARE DOTS CLOSE_SQUARE element_type| slice_type| TYPE type_name;

literal_value ::= OPEN_CURLY element_list CLOSE_CURLY| OPEN_CURLY CLOSE_CURLY;

element_list ::=  keyed_element sub_element_list;
sub_element_list ::= COMMA keyed_element sub_element_list|;
keyed_element ::= key COLON element|element;
key ::= field_name|literal_value;
field_name ::= IDENTIFIER;
element ::= expression|literal_value;
basic_lit ::= INT_LIT| STRING_TEXT;
operand_name ::= IDENTIFIER|qualified_ident;
qualified_ident ::= DOT package_name DOT IDENTIFIER;
function_lit ::= FUNC function;
primary_expr ::=operand|primary_expr selector|primary_expr index|primary_expr slice|primary_expr arguments;
selector ::=DOT IDENTIFIER;
index ::=OPEN_SQUARE expression CLOSE_SQUARE;
slice ::=OPEN_SQUARE sub_slice COLON sub_slice CLOSE_SQUARE|OPEN_SQUARE sub_slice COLON expression COLON expression CLOSE_SQUARE;
sub_slice ::= expression|;
arguments ::=OPEN_PARAN sub_arguments CLOSE_PARAN;
sub_arguments ::= sub_sub_arguments|;
sub_sub_arguments ::= sub_type expression_list;
sub_type ::= sub_sub_type|;
sub_sub_type ::= TYPE type COMMA;
method_expr ::= DOT receiver_type DOT method_name;
receiver_type ::= OPEN_PARAN ASTRISK type_name CLOSE_PARAN|OPEN_PARAN type_name CLOSE_PARAN;
statement ::= declaration|simple_stmt SEMI_COLON|return_stmt SEMI_COLON|break_stmt SEMI_COLON|block SEMI_COLON|block|if_stmt SEMI_COLON|if_stmt|switch_stmt SEMI_COLON|switch_stmt|for_stmt SEMI_COLON|for_stmt;
simple_stmt ::=expression_stmt|inc_dec_stmt|assignment|short_var_decl;
expression_stmt ::=expression;
inc_dec_stmt ::=expression sub_inc_dec_stmt;
sub_inc_dec_stmt ::= INCREMENT |DECREMENT;
assignment ::= expression_list assign_op expression_list;
assign_op ::= sub_assign_op EQUAL;
sub_assign_op ::= add_op|mul_op|;

if_stmt ::= IF simple_stmt SEMI_COLON expression block sub_else_stmt| IF expression block sub_else_stmt;
sub_else_stmt ::= ELSE sub_sub_else_stmt|;
sub_sub_else_stmt ::= if_stmt |block;
switch_stmt ::= expr_switch_stmt;
expr_switch_stmt ::= SWITCH sub_expr_switch_stmt sub_expr_switch_expr_stmt OPEN_CURLY zero_expr_switch_stmt CLOSE_CURLY;
sub_expr_switch_stmt ::= simple_stmt SEMI_COLON|;
sub_expr_switch_expr_stmt ::= expression|;
zero_expr_switch_stmt ::= expr_case_clause zero_expr_switch_stmt|;
expr_case_clause ::= expr_switch_case COLON statement_list;
expr_switch_case ::= CASE expression_list|DEFAULT;
for_stmt ::= FOR sub_for_stmt block;
sub_for_stmt ::= condition|for_clause|;
condition ::= expression;
for_clause ::= zero_one_init_stmt SEMI_COLON zero_one_condition SEMI_COLON zero_one_post_stmt;
zero_one_init_stmt ::=init_stmt|;
zero_one_condition ::=condition|;
zero_one_post_stmt ::=post_stmt|;
sub_semi_colon::= SEMI_COLON|;
init_stmt ::= simple_stmt;
post_stmt ::= simple_stmt;
return_stmt ::= RETURN sub_return_stmt;
sub_return_stmt ::= expression_list|;
break_stmt ::= BREAK;
source_file ::= package_clause sub_semi_colon sub_import_decll sub_top_level_decl;
sub_import_decll ::= import_decl sub_semi_colon sub_import_decll|;
sub_top_level_decl ::= top_level_decl sub_top_level_decl|;
package_clause ::= PACKAGE package_name;
package_name ::= IDENTIFIER;
import_decl ::= IMPORT sub_import_decl;
sub_import_decl ::= import_spec |OPEN_PARAN sub_sub_import_decl CLOSE_PARAN;
sub_sub_import_decl ::= import_spec sub_semi_colon sub_sub_import_decl|;
import_spec ::= sub_import_spec import_path;
sub_import_spec ::= DOT|package_name|;
import_path ::= STRING_TEXT;





